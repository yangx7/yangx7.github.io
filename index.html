<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Yang Xiao">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-Heap" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/02/20/Heap/" class="article-date">
  <time class="dt-published" datetime="2022-02-20T08:00:00.000Z" itemprop="datePublished">2022-02-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/02/20/Heap/">Heap</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="What-is-Heap"><a href="#What-is-Heap" class="headerlink" title="What is Heap?"></a><span style="color:red">What is Heap?</span></h3><p>Heap is a special type of binary tree <span style="background-color:yellow"><strong>data structure</strong></span>, it should meets the following criteria:</p>
<ul>
<li>It is a complete binary tree. A complete binary tree is a binary tree in which every level, except possibly the last, is completely filled, and all nodes are as far left as possible.</li>
<li>The value of each node must be no greater than (or no less than) the value of its child nodes.</li>
</ul>
<h3 id="Classification-of-Heap"><a href="#Classification-of-Heap" class="headerlink" title="Classification of Heap"></a><span style="color:red">Classification of Heap</span></h3><p>There are two kinds of heaps: Max Heap and Min Heap.</p>
<ul>
<li><span style="background-color:yellow"><strong>Max Heap</strong></span>: Each node in the Heap has a value no less than its child nodes. Therefore, the top element (root node) has the largest value in the Heap.</li>
<li><span style="background-color:yellow"><strong>Min Heap</strong></span>: Each node in the Heap has a value no larger than its child nodes. Therefore, the top element (root node) has the smallest value in the Heap.<br>The figure below shows examples of Max Heap and Min Heap.<img src="https://s2.loli.net/2022/02/20/8ComVjrXAI25T4t.png" width="100%"></li>
</ul>
<h3 id="Transform-a-complete-binary-tree-into-an-array"><a href="#Transform-a-complete-binary-tree-into-an-array" class="headerlink" title="Transform a complete binary tree into an array"></a><span style="color:red">Transform a complete binary tree into an array</span></h3><p>We can implement a heap using an array. Since heap is a complete binary tree, we can store heap elements in the array and get following relationships (Assume the root node has index 1 in the array, its left node has index 2 etc.):</p>
<ul>
<li>Given a node has index n in the array, its parent node is at index <code>n / 2</code>.</li>
<li>Given a node has index n in the array, its left child is at index <code>n * 2</code>, its right child is at index <code>n * 2 + 1</code>.</li>
<li>Given the total number of nodes in the complete binary tree N, nodes with array index larger than the integer result of <code>N / 2</code> is a leaf node.</li>
</ul>
<h3 id="Implementation-of-Min-Heap"><a href="#Implementation-of-Min-Heap" class="headerlink" title="Implementation of Min Heap"></a><span style="color:red">Implementation of Min Heap</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinHeap</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[] minHeap;</span><br><span class="line">  <span class="keyword">int</span> heapSize;</span><br><span class="line">  <span class="keyword">int</span> realSize;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MinHeap</span><span class="params">(<span class="keyword">int</span> heapSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.minHeap = <span class="keyword">new</span> <span class="keyword">int</span>[heapSize + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">this</span>.heapSize = heapSize;</span><br><span class="line">    <span class="keyword">this</span>.realSize = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> element)</span> </span>&#123;</span><br><span class="line">    realSize++;</span><br><span class="line">    <span class="keyword">if</span> (realSize &gt; heapSize) &#123;</span><br><span class="line">      realSize--;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    minHeap[realSize] = element;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> index = realSize;</span><br><span class="line">    <span class="keyword">int</span> parent = index / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// if the newly added element is smaller than its parent node,</span></span><br><span class="line">    <span class="comment">// exchange the value of the newly added element with that of its parent</span></span><br><span class="line">    <span class="keyword">while</span> (minHeap[index] &lt; minHeap[parent] &amp;&amp; index &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">int</span> temp = minHeap[index];</span><br><span class="line">      minHeap[index] = minHeap[parent];</span><br><span class="line">      minHeap[parent] = temp;</span><br><span class="line">      index = parent;</span><br><span class="line">      parent = index / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> minHeap[<span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (realSize &lt; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = minHeap[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// put the last element in the heap to the top of the heap</span></span><br><span class="line">    minHeap[<span class="number">1</span>] = minHeap[realSize];</span><br><span class="line">    realSize--;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (index &lt;= realSize / <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">int</span> left = index * <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">int</span> right = index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (minHeap[index] &lt;= minHeap[left] &amp;&amp; minHeap[index] &lt;= minHeap[right]) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">      if the parent element is larger than its left or right child,</span></span><br><span class="line"><span class="comment">      its value needs to be exchanged with the smaller value of the left and right child</span></span><br><span class="line"><span class="comment">      **/</span></span><br><span class="line">      <span class="keyword">if</span> (minHeap[left] &lt; minHeap[right]) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = minHeap[left];</span><br><span class="line">        minHeap[left] = minHeap[index];</span><br><span class="line">        minHeap[index] = temp;</span><br><span class="line">        index = left;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = minHeap[right];</span><br><span class="line">        minHeap[right] = minHeap[index];</span><br><span class="line">        minHeap[index] = temp;</span><br><span class="line">        index = right;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> realSize;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Implementation-of-Max-Heap"><a href="#Implementation-of-Max-Heap" class="headerlink" title="Implementation of Max Heap"></a><span style="color:red">Implementation of Max Heap</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxHeap</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[] maxHeap;</span><br><span class="line">  <span class="keyword">int</span> heapSize;</span><br><span class="line">  <span class="keyword">int</span> realSize;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MaxHeap</span><span class="params">(<span class="keyword">int</span> heapSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.maxHeap = <span class="keyword">new</span> <span class="keyword">int</span>[heapSize + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">this</span>.heapSize = heapSize;</span><br><span class="line">    <span class="keyword">this</span>.realSize = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> element)</span> </span>&#123;</span><br><span class="line">    realSize++;</span><br><span class="line">    <span class="keyword">if</span> (realSize &gt; heapSize) &#123;</span><br><span class="line">      realSize--;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    maxHeap[realSize] = element;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> index = realSize;</span><br><span class="line">    <span class="keyword">int</span> parent = index / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// if the newly added element is larger than its parent node,</span></span><br><span class="line">    <span class="comment">// exchange the value of the newly added element with that of its parent</span></span><br><span class="line">    <span class="keyword">while</span> (maxHeap[index] &gt; maxHeap[parent] &amp;&amp; index &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">int</span> temp = maxHeap[index];</span><br><span class="line">      maxHeap[index] = maxHeap[parent];</span><br><span class="line">      maxHeap[parent] = temp;</span><br><span class="line">      index = parent;</span><br><span class="line">      parent = index / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> maxHeap[<span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (realSize &lt; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = maxHeap[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// put the last element in the heap to the top of the heap</span></span><br><span class="line">    maxHeap[<span class="number">1</span>] = maxHeap[realSize];</span><br><span class="line">    realSize--;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (index &lt;= realSize / <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">int</span> left = index * <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">int</span> right = index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (maxHeap[index] &gt;= minHeap[left] &amp;&amp; minHeap[index] &gt;= minHeap[right]) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">      if the parent element is samller than its left or right child,</span></span><br><span class="line"><span class="comment">      its value needs to be exchanged with the smaller value of the left and right child</span></span><br><span class="line"><span class="comment">      **/</span></span><br><span class="line">      <span class="keyword">if</span> (maxHeap[left] &gt; maxHeap[right]) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = maxHeap[left];</span><br><span class="line">        maxHeap[left] = maxHeap[index];</span><br><span class="line">        maxHeap[index] = temp;</span><br><span class="line">        index = left;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = maxHeap[right];</span><br><span class="line">        maxHeap[right] = maxHeap[index];</span><br><span class="line">        maxHeap[index] = temp;</span><br><span class="line">        index = right;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> realSize;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Time-and-Space-Complexity"><a href="#Time-and-Space-Complexity" class="headerlink" title="Time and Space Complexity"></a><span style="color:red">Time and Space Complexity</span></h3><table>
<thead>
<tr>
<th>Heap method</th>
<th>Time complexity</th>
<th>Space complexity</th>
</tr>
</thead>
<tbody><tr>
<td>Construct a Heap</td>
<td>O(N)</td>
<td>O(N)</td>
</tr>
<tr>
<td>Insert an element</td>
<td>O(logN)</td>
<td>O(1)</td>
</tr>
<tr>
<td>Get the top element</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>Delete the top element</td>
<td>O(logN)</td>
<td>O(1)</td>
</tr>
<tr>
<td>Get the size of a Heap</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody></table>
<p>N is the number of elements in the heap.</p>
<p><strong>Note: To create a heap, there are two ways:</strong></p>
<ul>
<li>Create an empty heap and repeatly insert elements one by one, this way takes O(NlogN) time.</li>
<li>Heapify (means converting a group of data into a Heap) directly will take O(N) time.<br>Refer to <a target="_blank" rel="noopener" href="https://leetcode.com/explore/learn/card/heap/644/common-applications-of-heap/4145/">this</a> for more information.</li>
</ul>
<h3 id="Heap-Sort"><a href="#Heap-Sort" class="headerlink" title="Heap Sort"></a><span style="color:red">Heap Sort</span></h3><p>Heap Sort sorts a group of unordered elements using the Heap data structure.</p>
<ul>
<li>To sort a group of unordered elements in <strong>ascending order</strong>:<ol>
<li>Heapify all elements into a <strong>Min Heap</strong>.</li>
<li>Record and delete the top element.</li>
<li>Put the top element into an array that stores all sorted elements. Now the Heap will remain a Min Heap.</li>
<li>Repeat steps 2 and 3 until the Heap is empty. The array will contain all elements sorted in ascending order.</li>
</ol>
</li>
<li>To sort a group of unordered elements in <strong>descending order</strong>:<ol>
<li>Heapify all elements into a <strong>Max Heap</strong>.</li>
<li>Record and delete the top element.</li>
<li>Put the top element into an array that stores all sorted elements. Now the Heap will remain a Max Heap.</li>
<li>Repeat steps 2 and 3 until the Heap is empty. The array will contain all elements sorted in descending order.</li>
</ol>
</li>
</ul>
<p>Let N be the total number of elements.<br><strong>Time Complexity: <span style="background-color:yellow">O(NlogN)</span></strong><br><strong>Space Complexity: <span style="background-color:yellow">O(N)</span></strong></p>
<h3 id="Priority-Queue"><a href="#Priority-Queue" class="headerlink" title="Priority Queue"></a><span style="color:red">Priority Queue</span></h3><ul>
<li>Priority Queue is an <span style="background-color:yellow"><strong>abstract data type</strong></span> in which each element additionally has a “priority” associated with it. In a priority queue, an element with high priority is served before an element with low priority.</li>
<li><strong>A priority queue is an abstract data type, while a Heap is a data structure. Therefore, a Heap is not a Priority Queue, but a way to implement a Priority Queue.</strong></li>
</ul>
<h3 id="Further-Discussion"><a href="#Further-Discussion" class="headerlink" title="Further Discussion"></a><span style="color:red">Further Discussion</span></h3><p>Heap is often used in these two class of problems:</p>
<ul>
<li>Obtain top k largest or smallest elements.</li>
<li>Obtain the k-th largest or smallest element.</li>
</ul>
<p>To obtain <strong>top k largest</strong> elements, we can use either <strong>Max Heap</strong> or <strong>Min Heap</strong>:<br>Use <strong>Max Heap</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;(Collections.reverseOrder());</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">    pq.add(num);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (k - <span class="number">1</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    pq.poll();</span><br><span class="line">    k--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// pq.peek() is the k-th largest element</span></span><br><span class="line">  <span class="comment">// the first k elements popped out from pq are the top k largest elements</span></span><br><span class="line">  <span class="keyword">return</span> pq.peek();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Use <strong>Min Heap (a more efficient way)</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">    pq.add(num);</span><br><span class="line">    <span class="keyword">if</span> (pq.size() &gt; k) &#123;</span><br><span class="line">      pq.poll();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// pq.peek() is the k-th largest element</span></span><br><span class="line">  <span class="comment">// pq contains top k largest elements</span></span><br><span class="line">  <span class="keyword">return</span> pq.peek();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>To obtain <strong>top k smallest</strong> elements, we can use either <strong>Max Heap</strong> or <strong>Min Heap</strong>:<br>Use <strong>Min Heap</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthSmallest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">    pq.add(num);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (k - <span class="number">1</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    pq.poll();</span><br><span class="line">    k--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// pq.peek() is the k-th smallest element</span></span><br><span class="line">  <span class="comment">// the first k elements popped out from pq are the top k smallest elements</span></span><br><span class="line">  <span class="keyword">return</span> pq.peek();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Use <strong>Max Heap (a more efficient way)</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthSmallest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;(Collections.reverseOrder());</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">    pq.add(num);</span><br><span class="line">    <span class="keyword">if</span> (pq.size() &gt; k) &#123;</span><br><span class="line">      pq.poll();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// pq.peek() is the k-th smallest element</span></span><br><span class="line">  <span class="comment">// pq contains top k smallest elements</span></span><br><span class="line">  <span class="keyword">return</span> pq.peek();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>related questions:</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/kth-largest-element-in-an-array/">https://leetcode.com/problems/kth-largest-element-in-an-array/</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/">https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/</a></li>
</ul>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a><span style="color:red">Reference</span></h3><ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/explore/learn/card/heap/645/applications-of-heap">https://leetcode.com/explore/learn/card/heap/645/applications-of-heap</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/02/20/Heap/" data-id="ckzw6agpg0007qgvbhe729ice" data-title="Heap" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Monotonic-Stack" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/02/20/Monotonic-Stack/" class="article-date">
  <time class="dt-published" datetime="2022-02-20T08:00:00.000Z" itemprop="datePublished">2022-02-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/02/20/Monotonic-Stack/">Monotonic Stack</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="What-is-Monotonic-Stack"><a href="#What-is-Monotonic-Stack" class="headerlink" title="What is Monotonic Stack?"></a><span style="color:red">What is Monotonic Stack?</span></h3><ul>
<li>A Monotonic Stack is a stack with its elements ordered monotonically from stack bottom to top. So we have two kinds of monotonic stacks: <strong>monotonic increase stack</strong> and <strong>monotonic decrease stack</strong>.</li>
<li>Monotonic Stack usually works as a <span style="background-color:yellow"><strong>technique</strong></span> to resolve problems that requires finding the next/previous greater/smaller element of each element in a collection.</li>
<li>To obtain <strong>previous/next samller element</strong>, use <strong>monotonic increase stack</strong>.</li>
<li>To obtain <strong>previous/next greater element</strong>, use <strong>monotonic decrease stack</strong>.</li>
</ul>
<h3 id="Basic-Template-for-monotonic-increase-stack"><a href="#Basic-Template-for-monotonic-increase-stack" class="headerlink" title="Basic Template for monotonic increase stack"></a><span style="color:red">Basic Template for monotonic increase stack</span></h3><p><strong>Get previous smaller element:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Given an array nums, return a new array ans,</span></span><br><span class="line"><span class="comment">where ans[i] contains the previous samller element of nums[i] in the nums array.</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">int</span>[] previousSmallerElement(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">  <span class="keyword">int</span> n = nums.length;</span><br><span class="line">  Deque&lt;Integer&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">  <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="comment">// stack is a monotonic increase stack</span></span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; nums[stack.peek()] &gt; nums[i]) &#123;</span><br><span class="line">      stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    ans[i] = stack.isEmpty() ? -<span class="number">1</span> : nums[stack.peek()];</span><br><span class="line">    <span class="comment">// store index instead of the value in the stack</span></span><br><span class="line">    stack.push(i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Get next smaller element:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Given an array nums, return a new array ans,</span></span><br><span class="line"><span class="comment">where ans[i] contains the next samller element of nums[i] in the nums array.</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">int</span>[] nextSmallerElement(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">  <span class="keyword">int</span> n = nums.length;</span><br><span class="line">  Deque&lt;Integer&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">  <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="comment">// stack is a monotonic increase stack</span></span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; nums[stack.peek()] &gt; nums[i]) &#123;</span><br><span class="line">      ans[stack.pop()] = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// store index instead of the value in the stack</span></span><br><span class="line">    stack.push(i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// if there is no next smaller element for some element, return -1</span></span><br><span class="line">  <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">    ans[stack.pop()] = -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Key-Attributes"><a href="#Key-Attributes" class="headerlink" title="Key Attributes:"></a>Key Attributes:</h4><ul>
<li>To keep the stack monotonic increasing, once we find the peek element of the stack is larger than the current element to be pushed to the stack, pop out the current peek element from the stack.</li>
<li>We push every element of the nums array to the stack once.</li>
<li>Since it is easy to access the value by index, we usually store index instead of the value in the stack.</li>
<li>To get previous smaller element, update ans[i] outside the while loop since current stack.peek() is less than nums[i].</li>
<li>To get next smaller element, update ans[i] inside the while loop since each stack.peek() is greater than nums[i].</li>
</ul>
<h3 id="Basic-Template-for-monotonic-decrease-stack"><a href="#Basic-Template-for-monotonic-decrease-stack" class="headerlink" title="Basic Template for monotonic decrease stack"></a><span style="color:red">Basic Template for monotonic decrease stack</span></h3><p><strong>Get previous greater element:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Given an array nums, return a new array ans,</span></span><br><span class="line"><span class="comment">where ans[i] contains the previous greater element of nums[i] in the nums array.</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">int</span>[] previousGreaterElement(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">  <span class="keyword">int</span> n = nums.length;</span><br><span class="line">  Deque&lt;Integer&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">  <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="comment">// stack is a monotonic decrease stack</span></span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; nums[stack.peek()] &lt; nums[i]) &#123;</span><br><span class="line">      stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    ans[i] = stack.isEmpty() ? -<span class="number">1</span> : nums[stack.peek()];</span><br><span class="line">    <span class="comment">// store index instead of the value in the stack</span></span><br><span class="line">    stack.push(i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Get next greater element:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Given an array nums, return a new array ans,</span></span><br><span class="line"><span class="comment">where ans[i] contains the next greater element of nums[i] in the nums array.</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">int</span>[] nextGreaterElement(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">  <span class="keyword">int</span> n = nums.length;</span><br><span class="line">  Deque&lt;Integer&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">  <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="comment">// stack is a monotonic decrease stack</span></span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; nums[stack.peek()] &lt; nums[i]) &#123;</span><br><span class="line">      ans[stack.pop()] = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// store index instead of the value in the stack</span></span><br><span class="line">    stack.push(i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// if there is no next greater element for some element, return -1</span></span><br><span class="line">  <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">    ans[stack.pop()] = -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Key-Attributes-1"><a href="#Key-Attributes-1" class="headerlink" title="Key Attributes:"></a>Key Attributes:</h4><ul>
<li>Similar to monotonic increase stack, to keep the stack monotonic decreasing, once we find the peek element of the stack is samller than the current element to be pushed to the stack, pop out the current peek element from the stack.</li>
<li>To get previous greater element, update ans[i] outside the while loop since current stack.peek() is greater than nums[i].</li>
<li>To get next greater element, update ans[i] inside the while loop since each stack.peek() is less than nums[i].</li>
</ul>
<p><strong>related questions:</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/next-greater-element-i/">https://leetcode.com/problems/next-greater-element-i/</a></li>
</ul>
<h3 id="Time-and-Space-Complexity"><a href="#Time-and-Space-Complexity" class="headerlink" title="Time and Space Complexity"></a><span style="color:red">Time and Space Complexity</span></h3><p><strong>Time Complexity: <span style="background-color:yellow">O(N)</span></strong><br>N is the size of the given array. We traverse the array, push and pop every element from the array once, so it takes O(N) time.</p>
<p><strong>Space Complexity: <span style="background-color:yellow">O(N)</span></strong><br>We keep a stack and in worst case, it stores all elements of the given array, so space complexity is O(N).</p>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a><span style="color:red">Reference</span></h3><ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/sum-of-subarray-minimums/discuss/178876/stack-solution-with-very-detailed-explanation-step-by-step">https://leetcode.com/problems/sum-of-subarray-minimums/discuss/178876/stack-solution-with-very-detailed-explanation-step-by-step</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/02/20/Monotonic-Stack/" data-id="ckzw6agph0009qgvb3go7grt3" data-title="Monotonic Stack" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Topological-Sorting" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/02/20/Topological-Sorting/" class="article-date">
  <time class="dt-published" datetime="2022-02-20T08:00:00.000Z" itemprop="datePublished">2022-02-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/02/20/Topological-Sorting/">Topological Sorting</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="What-is-Topological-Sorting"><a href="#What-is-Topological-Sorting" class="headerlink" title="What is Topological Sorting?"></a><span style="color:red">What is Topological Sorting?</span></h3><p>Topological sorting provides a linear sorting based on the required ordering between vertices in a directed acyclic graph(DAG). To be specific, given vertices u and v, to reach vertex v, we must have reached vertex u first. In topological sorting, u has to appear before v in the ordering. The most popular algorithm for topological sorting is Kahn’s algorithm.</p>
<h3 id="Kahn’s-algorithm"><a href="#Kahn’s-algorithm" class="headerlink" title="Kahn’s algorithm"></a><span style="color:red">Kahn’s algorithm</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">We are give a graph with n nodes labeled from 0 to n - 1.</span></span><br><span class="line"><span class="comment">An array prerequisites, prerequisites[i] = [ui, vi] indicates that you must reach vi first if you want to reach ui,</span></span><br><span class="line"><span class="comment">return the ordering of vertices you should take to visit all vertices</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">int</span>[] Kahn(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] prerequisites) &#123;</span><br><span class="line">  Map&lt;Integer, List&lt;Integer&gt;&gt; adj = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    adj.put(i, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span>[] indegree = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span>[] pre : prerequisites) &#123;</span><br><span class="line">    adj.get(pre[<span class="number">1</span>]).add(pre[<span class="number">0</span>]);</span><br><span class="line">    indegree[pre[<span class="number">0</span>]]++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (indegree[i] == <span class="number">0</span>) &#123;</span><br><span class="line">      queue.offer(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">  <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">int</span> curr = queue.poll();</span><br><span class="line">    ans[index++] = curr;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> next : adj.get(curr)) &#123;</span><br><span class="line">      indegree[next]--;</span><br><span class="line">      <span class="keyword">if</span> (indegree[next] == <span class="number">0</span>) &#123;</span><br><span class="line">        queue.offer(next);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (index != n) &#123;</span><br><span class="line">    <span class="comment">// if there is no valid topological sorting, return an empty array</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Key-Attributes"><a href="#Key-Attributes" class="headerlink" title="Key Attributes:"></a>Key Attributes:</h4><ul>
<li>Topological sorting only works with directed acyclic graph(DAG).</li>
<li>There must be at least one vertex in the graph with an indegree of 0. If all vertices in the graph have a non-zero indegree, then all vertices need at least one vertex as a predecessor. In this case, no vertex can serve as the starting vertex.</li>
</ul>
<p><strong>related questions:</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/course-schedule-ii/">https://leetcode.com/problems/course-schedule-ii/</a></li>
</ul>
<h3 id="Time-and-Space-Complexity"><a href="#Time-and-Space-Complexity" class="headerlink" title="Time and Space Complexity"></a><span style="color:red">Time and Space Complexity</span></h3><p><strong>Time Complexity: <span style="background-color:yellow">O(V + E)</span></strong></p>
<ul>
<li>V represents the number of vertices, and E represents the number of edges.</li>
<li>Building the adjacency list will take O(E) time, as we must iterate over all edges.</li>
<li>We will repeatedly visit each vertex with an indegree of zero and decrement the indegree of all vertices that have this vertex as a prerequisite. In the worst case, we will visit every vertex and decrement every outgoing edge once. This part will take O(V + E) time.</li>
<li>Therefore, the total time complexity is <code>O(E) + O(V + E) = O(V + E)</code>.</li>
</ul>
<p><strong>Space Complexity: <span style="background-color:yellow">O(V + E)</span></strong></p>
<ul>
<li>Building the adjacency list will take O(E) space.</li>
<li>Storing the indegree for each vertex requires O(V) space.</li>
<li>The queue can contain at most V vertices, so the queue also requires O(V) space.</li>
<li>Therefore, the total time complexity is <code>O(E) + O(V) = O(V + E)</code>.</li>
</ul>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a><span style="color:red">Reference</span></h3><ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/explore/learn/card/graph/623/kahns-algorithm-for-topological-sorting">https://leetcode.com/explore/learn/card/graph/623/kahns-algorithm-for-topological-sorting</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/02/20/Topological-Sorting/" data-id="ckzw6agpi000bqgvb8j7fca16" data-title="Topological Sorting" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Bellman-Ford-Algorithm" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/02/19/Bellman-Ford-Algorithm/" class="article-date">
  <time class="dt-published" datetime="2022-02-19T08:00:00.000Z" itemprop="datePublished">2022-02-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/02/19/Bellman-Ford-Algorithm/">Bellman Ford Algorithm</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="What-is-Bellman-Ford-Algorithm"><a href="#What-is-Bellman-Ford-Algorithm" class="headerlink" title="What is Bellman Ford Algorithm?"></a><span style="color:red">What is Bellman Ford Algorithm?</span></h3><ul>
<li>Bellman Ford Algorithm is an <span style="background-color:yellow"><strong>algorithm</strong></span> used to solve the “single-source shortest path” problem in a <strong>weighted directed graph with negative weights</strong>.</li>
<li>“single source shortest path” problem is explained in the <a href="../Dijkstra's-Algorithm/">Dijkstra’s-Algorithm</a> post.</li>
<li>Edge Relaxation: it is the operation to find a shorter distance path from the source to the target node and update current record.</li>
</ul>
<h3 id="Two-Basic-Theorems-to-support-Bellman-Ford-Algorithm"><a href="#Two-Basic-Theorems-to-support-Bellman-Ford-Algorithm" class="headerlink" title="Two Basic Theorems to support Bellman Ford Algorithm"></a><span style="color:red">Two Basic Theorems to support Bellman Ford Algorithm</span></h3><ol>
<li>In a “graph with no negative-weight cycles” with N vertices, the shortest path between any two vertices has at most <code>N - 1</code> edges. Thus, Bellman Ford Algorithm can detect whether there exists a “negative weight cycle” in the graph.<br><strong>Detection method</strong>: After relaxing each edge <code>N - 1</code> times, perform the Nth relaxation. According to the Bellman Ford algorithm, all distances must be the shortest after relaxing each edge <code>N - 1</code> times. However, after the Nth relaxation, if there exists distances[u] + weight(u, v) &lt; distances(v) for any edge(u, v), it means there is a shorter path. At this point, we can conclude that there exists a “negative weight cycle”.</li>
<li>In a “graph with negative weight cycles”, there is no shortest path.</li>
</ol>
<hr>
<h3 id="Template-1"><a href="#Template-1" class="headerlink" title="Template 1"></a><span style="color:red">Template 1</span></h3><p><strong>Implement Bellman Ford algorithm with Dynamic Programming if we have the constraint that at most k edges are allowed from the source vertex to target vertex. If we don’t have this constraint, k is actually equals to <code>N - 1</code>, because based on theorem 1, the shortest path between any two vertices has at most <code>N - 1</code> edges.</strong></p>
<p><strong>Algorithm</strong>:</p>
<ol>
<li> Initialize two arrays prev and curr with a large value, set the source node value to 0.</li>
<li> Traverse all edges(u, v) and update the curr array curr[v] by picking the minimum between curr[v] and <code>prev[u] + weight</code>.</li>
<li> Repeat step 2 until K iterations are done.</li>
<li> If curr[target] is still the large value we initialized the array with, it means the target is not reachable from the source, return -1. Otherwise, return curr[target].</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">We are give a graph with n nodes labeled from 0 to n - 1.</span></span><br><span class="line"><span class="comment">An array edges listing all directed edges of a graph.</span></span><br><span class="line"><span class="comment">edges[i] = (ui, vi, wi), where ui is the source node, vi is the target node, wi is the weight it takes from ui to vi.</span></span><br><span class="line"><span class="comment">we need to find the shortest path having at most k edges to reach the target node from the source node.</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">int</span> Bellman-Ford(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] edges, <span class="keyword">int</span> source, <span class="keyword">int</span> target, <span class="keyword">int</span> k) &#123;</span><br><span class="line">  <span class="keyword">if</span> (source == target) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// after k iterations, prev array keeps the shortest path from souce to any vertices if at most k - 1 edges are allowed</span></span><br><span class="line">  <span class="keyword">int</span>[] prev = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">  <span class="comment">// after k iterations, curr array keeps the shortest path from souce to any vertices if at most k edges are allowed</span></span><br><span class="line">  <span class="keyword">int</span>[] curr = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">  Arrays.fill(prev, Integer.MAX_VALUE);</span><br><span class="line">  Arrays.fill(curr, Integer.MAX_VALUE);</span><br><span class="line">  prev[source] = <span class="number">0</span>;</span><br><span class="line">  curr[source] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] edge : edges) &#123;</span><br><span class="line">      <span class="keyword">int</span> from = edge[<span class="number">0</span>];</span><br><span class="line">      <span class="keyword">int</span> to = edge[<span class="number">1</span>];</span><br><span class="line">      <span class="keyword">int</span> weight = edge[<span class="number">2</span>];</span><br><span class="line">      <span class="keyword">if</span> (prev[from] &lt; Integer.MAX_VALUE) &#123;</span><br><span class="line">        curr[to] = Math.min(curr[to], prev[from] + weight);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    prev = curr.clone();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> curr[target] == Integer.MAX_VALUE ? -<span class="number">1</span> : curr[target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Time Complexity: <span style="background-color:yellow">O(k · E)</span></strong><br>we have k iterations and in each iteration, we go over all the edges in the graph.</p>
<p><strong>Space Complexity: <span style="background-color:yellow">O(V)</span></strong><br>V represents the number of vertices, we keep two arrays of length V.</p>
<p><strong>related questions:</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/cheapest-flights-within-k-stops/">https://leetcode.com/problems/cheapest-flights-within-k-stops/</a></li>
</ul>
<hr>
<h3 id="Template-2"><a href="#Template-2" class="headerlink" title="Template 2"></a><span style="color:red">Template 2</span></h3><p><strong>Implement Bellman Ford algorithm with “the Shortest Path Faster Algorithm” (SPFA algorithm). Note here we do not have the constraint that at most k edges are allowed from the source vertex to target vertex.</strong></p>
<p><strong>Algorithm</strong>:</p>
<ol>
<li> Initialize an array with a large value to keep the shortest path from the source to other vertices, set source vertex value to 0.</li>
<li> Initialize a queue and put the source to the queue.</li>
<li> Pop out the head from the queue, traverse all edges starting from the head and update the shortest path array, if any vertex value is changed, put it back to the queue since it may also impact other vertices value in the shortest path array.</li>
<li> Repeat step 3 and 4 until the queue is empty.</li>
<li> If arr[target] is still the large value we initialized the array with, it means the target is not reachable from the source, return -1. Otherwise, return arr[target].</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">We are give a graph with n nodes labeled from 0 to n - 1.</span></span><br><span class="line"><span class="comment">An array edges listing all directed edges of a graph.</span></span><br><span class="line"><span class="comment">edges[i] = (ui, vi, wi), where ui is the source node, vi is the target node, wi is the weight it takes from ui to vi.</span></span><br><span class="line"><span class="comment">we need to find the shortest path costing minimum weight to reach the target node from the source node.</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">int</span> Bellman-Ford(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] edges, <span class="keyword">int</span> source, <span class="keyword">int</span> target) &#123;</span><br><span class="line">  <span class="comment">// Create the adjacency list of the graph</span></span><br><span class="line">  Map&lt;Integer, List&lt;<span class="keyword">int</span>[]&gt;&gt; adj = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    adj.put(i, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span>[] edge : edges) &#123;</span><br><span class="line">    adj.get(edge[<span class="number">0</span>]).add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;edge[<span class="number">1</span>], edge[<span class="number">2</span>]&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span>[] paths = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">  Arrays.fill(paths, Integer.MAX_VALUE);</span><br><span class="line">  paths[source] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">  queue.offer(source);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">int</span> curr = queue.poll();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] edge : adj.get(curr)) &#123;</span><br><span class="line">      <span class="keyword">int</span> next = edge[<span class="number">0</span>];</span><br><span class="line">      <span class="keyword">int</span> weight = edge[<span class="number">1</span>];</span><br><span class="line">      <span class="keyword">if</span> (paths[curr] + weight &lt; paths[next]) &#123;</span><br><span class="line">        paths[next] = paths[curr] + weight;</span><br><span class="line">        queue.offer(next);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> paths[target] == Integer.MAX_VALUE ? -<span class="number">1</span> : paths[target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Time Complexity: <span style="background-color:yellow">O(V · E)</span></strong></p>
<ul>
<li>V represents the number of vertices, and E represents the number of edges.</li>
<li>Build the adjacency list takes O(V + E) time.</li>
<li>We iterate through all the vertices, and in each iteration, we’ll perform a relaxation operation for each appropriate edge. Therefore, the time complexity would be O(V · E).</li>
<li>Therefore, the overall time complexity is <code>O(V + E) + O(V · E) = O(V · E)</code>.</li>
<li>On average, the SPFA tends to be faster than the template 1 if there is no constraint of at most k edges are allowed.</li>
</ul>
<p><strong>Space Complexity: <span style="background-color:yellow">O(V + E)</span></strong></p>
<ul>
<li>Building the adjacency list will take O(E) space.</li>
<li>Keep the paths array takes O(V) space.</li>
<li>The queue keeps at most V vertices, it takes O(V) space.</li>
<li>Therefore, the overall space complexity is <code>O(V) + O(E) = O(V + E)</code>.</li>
</ul>
<p><strong>related questions:</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/path-with-minimum-effort/">https://leetcode.com/problems/path-with-minimum-effort/</a></li>
</ul>
<h3 id="Difference-between-BFS-Dijkstra’s-Algorithm-and-Bellman-Ford-Algorithm-in-finding-shortest-path"><a href="#Difference-between-BFS-Dijkstra’s-Algorithm-and-Bellman-Ford-Algorithm-in-finding-shortest-path" class="headerlink" title="Difference between BFS, Dijkstra’s Algorithm and Bellman Ford Algorithm in finding shortest path"></a><span style="color:red">Difference between BFS, Dijkstra’s Algorithm and Bellman Ford Algorithm in finding shortest path</span></h3><ul>
<li>BFS can find the shortest path from the source to the target in a tree, 2D array or unweighted graph.</li>
<li>Dijkstra’s Algorithm can find the shortest path in the weighted directed graph with non-negative weights.</li>
<li>Bellman Ford Algorithm can find the shortest path in the weighted directed graph with negative weights, so it can cover cases of Dijkstra’s Algorithm.</li>
</ul>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a><span style="color:red">Reference</span></h3><ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/explore/learn/card/graph/622/single-source-shortest-path-algorithm/3864/">https://leetcode.com/explore/learn/card/graph/622/single-source-shortest-path-algorithm/3864/</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/02/19/Bellman-Ford-Algorithm/" data-id="ckzw6agp80000qgvb0yskboon" data-title="Bellman Ford Algorithm" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Dijkstra&#39;s-Algorithm" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/02/19/Dijkstra's-Algorithm/" class="article-date">
  <time class="dt-published" datetime="2022-02-19T08:00:00.000Z" itemprop="datePublished">2022-02-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/02/19/Dijkstra's-Algorithm/">Dijkstra&#39;s Algorithm</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="What-is-Dijkstra’s-Algorithm"><a href="#What-is-Dijkstra’s-Algorithm" class="headerlink" title="What is Dijkstra’s Algorithm?"></a><span style="color:red">What is Dijkstra’s Algorithm?</span></h3><ul>
<li>Dijkstra’s algorithm is an <span style="background-color:yellow"><strong>algorithm</strong></span> used to solve the “single-source shortest path” problem in a <strong>weighted directed graph with non-negative weights</strong>.</li>
<li>“single source shortest path” problems: Given the starting vertex, find the shortest path to any of the vertices in a weighted graph. Once we solve this, we can easily acquire the shortest paths between the starting vertex and a given target vertex.</li>
<li>Note the difference between unweighted graphs and weighted graphs, below left is an unweighted graph, every edge has the same weight/distance; right is a weighted graph, every edge may have different weight/distance.<table>
<thead>
<tr>
<th>Unweighted Graph</th>
<th>Weighted Graph</th>
</tr>
</thead>
<tbody><tr>
<td><img src="https://s2.loli.net/2022/02/20/Glpw74LOD3Un9MI.jpg" width="60%" align="left"></td>
<td><img src="https://s2.loli.net/2022/02/20/iDa85eU6QdbC2pc.jpg" width="60%" align="left"></td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="Implement-Dijkstra’s-Algorithm"><a href="#Implement-Dijkstra’s-Algorithm" class="headerlink" title="Implement Dijkstra’s Algorithm"></a><span style="color:red">Implement Dijkstra’s Algorithm</span></h3><p>Main idea is taking the starting point as the center and gradually expand outward while updating the shortest path to reach other vertices. Dijkstra’s Algorithm uses a “greedy approach”. Each step selects the “minimum weight” from the currently reached vertices to find the shortest path to other vertices.</p>
<p><strong>Algorithm</strong>:</p>
<ol>
<li> For all vertices, initialize the paths table with a large value, so far, no vertex has been visited.</li>
<li>Initialize min heap with the pair of startNode and its distance 0, store its distance in paths as 0. While the min heap is not empty:<ul>
<li>Pop out the currNode from the min heap.</li>
<li>Traverse all outgoing edges connected to currNode.</li>
<li>Add the neighborNode to the min heap only if the current path is less than the value at paths[neighborNode]. Update its value to current path value.</li>
</ul>
</li>
<li> Find the value paths[targetNode], if the value is still the large value we initialized the array with, it means the targetNode is not reachable from the startNode, return -1. Otherwise, return the value we get in the array.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">We are give a graph with n nodes labeled from 0 to n - 1.</span></span><br><span class="line"><span class="comment">An array edges listing all directed edges of a graph.</span></span><br><span class="line"><span class="comment">edges[i] = (ui, vi, wi), where ui is the source node, vi is the target node, wi is the weight it takes from ui to vi.</span></span><br><span class="line"><span class="comment">we need to find the shortest path costing minimum weight to reach the target node from the source node.</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] edges, <span class="keyword">int</span> source, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Create the adjacency list of the graph</span></span><br><span class="line">  Map&lt;Integer, List&lt;<span class="keyword">int</span>[]&gt;&gt; adj = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    adj.put(i, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span>[] edge : edges) &#123;</span><br><span class="line">    adj.get(edge[<span class="number">0</span>]).add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;edge[<span class="number">1</span>], edge[<span class="number">2</span>]&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span>[] paths = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">  Arrays.fill(paths, Integer.MAX_VALUE);</span><br><span class="line">  paths[source] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  PriorityQueue&lt;<span class="keyword">int</span>[]&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((v1, v2) -&gt; v1[<span class="number">1</span>] - v2[<span class="number">1</span>]);</span><br><span class="line">  pq.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;source, <span class="number">0</span>&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] curr = pq.poll();</span><br><span class="line">    <span class="keyword">int</span> currNode = curr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> weight = curr[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (weight &gt; paths[currNode]) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] next : adj.get(currNode)) &#123;</span><br><span class="line">      <span class="keyword">int</span> nextNode = next[<span class="number">0</span>];</span><br><span class="line">      <span class="keyword">int</span> nextWeight = next[<span class="number">1</span>];</span><br><span class="line">      <span class="keyword">if</span> (weight + nextWeight &lt; paths[nextNode]) &#123;</span><br><span class="line">        paths[nextNode] = weight + nextWeight;</span><br><span class="line">        pq.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;nextNode, paths[nextNode]&#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> paths[target] == Integer.MAX_VALUE ? -<span class="number">1</span> : paths[target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>related questions:</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/network-delay-time/">https://leetcode.com/problems/network-delay-time/</a></li>
</ul>
<h3 id="Time-and-Space-Complexity"><a href="#Time-and-Space-Complexity" class="headerlink" title="Time and Space Complexity"></a><span style="color:red">Time and Space Complexity</span></h3><p><strong>Time Complexity: <span style="background-color:yellow">O(V + ElogE)</span></strong></p>
<ul>
<li>V represents the number of vertices, and E represents the number of edges. The value of E can be at most <code>V · (V - 1)</code>.</li>
<li>Build the adjacency list takes O(V + E) time.</li>
<li>The maximum number of pairs that could be added to the priority queue is E. Thus, push and pop operations on the priority queue take O(logE) time.</li>
<li>Although the number of vertices in the priority queue could be equal to E, we will only visit each vertex only once. In total E edges will be traversed, and for each edge, there could be one priority queue insertion operation. This takes O(ElogE) time.</li>
<li>Therefore, the overall time complexity is <code>O(V + E) + O(ElogE) = O(V + ElogE)</code>.</li>
</ul>
<p><strong>Space Complexity: <span style="background-color:yellow">O(V + E)</span></strong></p>
<ul>
<li>Building the adjacency list will take O(E) space.</li>
<li>Keep the paths array takes O(V) space.</li>
<li>Each vertex could be added to the priority queue <code>V - 1</code> times, so in total priority queue takes <code>O(V · (V - 1)) = O(E)</code> space.</li>
<li>Therefore, the overall space complexity is <code>O(V) + O(E) = O(V + E)</code>.</li>
</ul>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a><span style="color:red">Reference</span></h3><ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/explore/learn/card/graph/622/single-source-shortest-path-algorithm/3862/">https://leetcode.com/explore/learn/card/graph/622/single-source-shortest-path-algorithm/3862/</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/02/19/Dijkstra's-Algorithm/" data-id="ckzw6agpf0005qgvb7zqq686e" data-title="Dijkstra&#39;s Algorithm" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Minimum-Spanning-Tree" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/02/19/Minimum-Spanning-Tree/" class="article-date">
  <time class="dt-published" datetime="2022-02-19T08:00:00.000Z" itemprop="datePublished">2022-02-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/02/19/Minimum-Spanning-Tree/">Minimum Spanning Tree</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="What-is-Minimum-Spanning-Tree"><a href="#What-is-Minimum-Spanning-Tree" class="headerlink" title="What is Minimum Spanning Tree?"></a><span style="color:red">What is Minimum Spanning Tree?</span></h3><p>A <strong>Spanning Tree</strong> is a connected subgraph in an undirected graph where all vertices are connected with the minimum number of edges.<br>In the below figure, all pink edges <span style="background-color:yellow">[(A, B), (A, C), (A, D), (A, E)]</span> form a tree, which is a spanning tree of this undirected graph. Note that <span style="background-color:yellow">[(A, E), (A, B), (B, C), (C, D)]</span> is also a spanning tree of the undirected graph. <strong>Thus, an undirected graph can have multiple spanning trees</strong>.<br><img src="https://s2.loli.net/2022/02/19/J7AEUHv8MX5qZlL.png" width="60%"></p>
<p>A <strong>Minimum Spanning Tree (MST)</strong> is a spanning tree with the minimum possible total edge weight in a weighted undirected graph.<br>In the below figure, a spanning tree formed by green edges <span style="background-color:yellow">[(A, E), (A, B), (B, C), (C, D)]</span> is one of the minimum spanning trees in this weighted undirected graph. Actually, <span style="background-color:yellow">[(A, E), (E, D), (A, B), (B, C)]</span> forms another minimum spanning tree of the weighted undirected graph. <strong>Thus, a weighted undirected graph can have multiple minimum spanning trees</strong>.<br><img src="https://s2.loli.net/2022/02/19/Sbumhe7NR9EBnw4.png" width="60%"></p>
<h3 id="Cut-Property"><a href="#Cut-Property" class="headerlink" title="Cut Property"></a><span style="color:red">Cut Property</span></h3><ul>
<li>In Graph theory, a “cut” is a partition of vertices in a graph into two disjoint subsets. Below figure illustrates a “cut”, where (B, A, E) forms one subset, and (C, D) forms the other subset.</li>
<li>A crossing edge is an edge that connects a vertex in one set with a vertex in the other set. In the below figure, (B, C), (A, C), (A, D), (E, D) are all “crossing edges”.<img src="https://s2.loli.net/2022/02/19/IZTp5qkSXb746Mz.png" width="60%"></li>
</ul>
<p><span style="background-color:yellow"><strong>For any cut C of the graph, if the weight of an edge E in the cut-set of C is strictly smaller than the weights of all other edges of the cut-set of C, then this edge belongs to all MSTs of the graph.</strong></span></p>
<p>So in the above figure, (B, C) belongs to all MSTs of the graph. The cut property provides theoretical support for the two algorithms for constructing a minimum spanning tree: Kruskal’s algorithm and Prim’s algorithm.</p>
<h3 id="Kruskal’s-Algorithm"><a href="#Kruskal’s-Algorithm" class="headerlink" title="Kruskal’s Algorithm"></a><span style="color:red">Kruskal’s Algorithm</span></h3><p>Kruskal’s algorithm is an <span style="background-color:yellow"><strong>algorithm</strong></span> to construct a MST of a weighted undirected graph.</p>
<p><strong>Algorithm</strong>:</p>
<ol>
<li> Ascending sort all edges by their weight. In practice, we can use min heap to get the edge wih the smallest weight.</li>
<li> Add edges in ascending order into the MST. Skip the edges that would produce cycles in the MST.</li>
<li> Repeat step 2 until <code>N - 1</code> edges are added.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  Given an array points representing integer coordinates of some points on a 2D-plane,</span></span><br><span class="line"><span class="comment">  where points[i] = [xi, yi].</span></span><br><span class="line"><span class="comment">  The cost of connecting two points [xi, yi] and [xj, yj] is the manhattan distance between them:</span></span><br><span class="line"><span class="comment">  |xi - xj| + |yi - yj|, where |val| denotes the absolute value of val.</span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Kruskal</span><span class="params">(<span class="keyword">int</span>[][] points)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (points == <span class="keyword">null</span> || points.length == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> size = points.length;</span><br><span class="line">    UnionFind uf = <span class="keyword">new</span> UnionFind(size);</span><br><span class="line">    PriorityQueue&lt;Edge&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((p1, p2) -&gt; p1.cost - p2.cost);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span>[] p1 = points[i];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; size; j++) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] p2 = points[j];</span><br><span class="line">        <span class="keyword">int</span> cost = Math.abs(p1[<span class="number">0</span>] - p2[<span class="number">0</span>]) + Math.abs(p1[<span class="number">1</span>] - p2[<span class="number">1</span>]);</span><br><span class="line">        Edge edge = <span class="keyword">new</span> Edge(i, j, cost);</span><br><span class="line">        pq.add(edge);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// to construct MST, we need (size - 1) edges</span></span><br><span class="line">    <span class="keyword">int</span> count = size - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!pq.isEmpty() &amp;&amp; count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      Edge edge = pq.poll();</span><br><span class="line">      <span class="keyword">if</span> (!uf.connected(edge.point1, edge.point2)) &#123;</span><br><span class="line">        uf.union(edge.point1, edge.point2);</span><br><span class="line">        ans += edge.cost;</span><br><span class="line">        count--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Edge</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> point1;</span><br><span class="line">    <span class="keyword">int</span> point2;</span><br><span class="line">    <span class="keyword">int</span> cost;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Edge</span><span class="params">(<span class="keyword">int</span> point1, <span class="keyword">int</span> point2, <span class="keyword">int</span> cost)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.point1 = point1;</span><br><span class="line">      <span class="keyword">this</span>.point2 = point2;</span><br><span class="line">      <span class="keyword">this</span>.cost = cost;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] root;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] rank;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">      root = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">      rank = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        root[i] = i;</span><br><span class="line">        rank[i] = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (x == root[x]) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> root[x] = find(root[x]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> rootX = find(x);</span><br><span class="line">      <span class="keyword">int</span> rootY = find(y);</span><br><span class="line">      <span class="keyword">if</span> (rootX == rootY) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (rank[rootX] &gt; rank[rootY]) &#123;</span><br><span class="line">        root[rootY] = rootX;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rank[rootX] &lt; rank[rootY]) &#123;</span><br><span class="line">        root[rootX] = rootY;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        root[rootY] = rootX;</span><br><span class="line">        rank[rootX]++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> find(x) == find(y);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Time Complexity: <span style="background-color:yellow">O(ElogE)</span></strong></p>
<ul>
<li>V represents the number of vertices, E represents the total number of edges. In our template, <code>E = V · (V - 1)</code>.</li>
<li>Building a priority queue takes O(ElogE) time.</li>
<li>To construct MST using Kruskal’s algorithm, We pop out each edge from the priority queue, and for each edge, we will look at whether both of the vertices of the edge belong to the same connected component and connect them if they do not belong to the same connected component. We only need <code>V - 1</code> edges to build MST, but in the worst case, the tree will not be complete until we reach the very last edge whose weight is the largest, it takes O(E) iterations. So it totally takes O(ElogE) time to pop out all edges from priority queue, to check connectivity and union vertices in the Union Find data structure totally takes O(Eα(V)) time, we can regard it as O(E) time.</li>
<li>Therefore, in total, the time complexity is <code>O(ElogE) + O(ElogE) + O(E) = O(ElogE)</code> time.</li>
</ul>
<p><strong>Space Complexity: <span style="background-color:yellow">O(V + E)</span></strong></p>
<ul>
<li>E represents the number of edges. Store all edges in a priority queue takes O(E) sapce.</li>
<li>V represents the number of vertices, Using the Union Find data structure requires O(V) space.</li>
<li>Therefore, in total, the space complexity is <code>O(V) + O(E) = O(V + E)</code> time.</li>
</ul>
<h3 id="Prim’s-Algorithm"><a href="#Prim’s-Algorithm" class="headerlink" title="Prim’s Algorithm"></a><span style="color:red">Prim’s Algorithm</span></h3><p>Prim’s algorithm is an <span style="background-color:yellow"><strong>algorithm</strong></span> to construct a MST of a weighted undirected graph.</p>
<p><strong>Algorithm</strong>:</p>
<ol>
<li> Keep two sets to store vertices: non-visited and visited. Initially, all vertices are in the non-visited set.</li>
<li> Randomly pick one vertex from non-visited set, put it in the visited set.</li>
<li> Among all edges between visited and non-visited vertices, find the edge with the smallest weight.</li>
<li> Move the new non-visited vertex belonging to the edge we found at step 3 to the visited set.</li>
<li> Repeat step 2 and 3 until all vertices are added to the visited set.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  Given an array points representing integer coordinates of some points on a 2D-plane,</span></span><br><span class="line"><span class="comment">  where points[i] = [xi, yi].</span></span><br><span class="line"><span class="comment">  The cost of connecting two points [xi, yi] and [xj, yj] is the manhattan distance between them:</span></span><br><span class="line"><span class="comment">  |xi - xj| + |yi - yj|, where |val| denotes the absolute value of val.</span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Prim</span><span class="params">(<span class="keyword">int</span>[][] points)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (points == <span class="keyword">null</span> || points.length == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> size = points.length;</span><br><span class="line">    <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[size];</span><br><span class="line">    PriorityQueue&lt;Edge&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((p1, p2) -&gt; p1.cost - p2.cost);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// select the first point to be added to the visited set</span></span><br><span class="line">    <span class="keyword">int</span>[] p1 = points[<span class="number">0</span>];</span><br><span class="line">    visited[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span>[] p2 = points[i];</span><br><span class="line">      <span class="keyword">int</span> cost = Math.abs(p1[<span class="number">0</span>] - p2[<span class="number">0</span>]) + Math.abs(p1[<span class="number">1</span>] - p2[<span class="number">1</span>]);</span><br><span class="line">      Edge edge = <span class="keyword">new</span> Edge(<span class="number">0</span>, i, cost);</span><br><span class="line">      pq.add(edge);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// we need to add remaining (size - 1) vertices to the visited set</span></span><br><span class="line">    <span class="keyword">int</span> count = size - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!pq.isEmpty() &amp;&amp; count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      Edge edge = pq.poll();</span><br><span class="line">      <span class="keyword">int</span> p2 = edge.point2;</span><br><span class="line">      <span class="keyword">if</span> (!visited[p2]) &#123;</span><br><span class="line">        visited[p2] = <span class="keyword">true</span>;</span><br><span class="line">        ans += edge.cost;</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> cost = Math.abs(points[p2][<span class="number">0</span>] - points[i][<span class="number">0</span>]) + Math.abs(points[p2][<span class="number">1</span>] - points[i][<span class="number">0</span>]);</span><br><span class="line">            pq.add(<span class="keyword">new</span> Edge(p2, i, cost));</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Edge</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> point1;</span><br><span class="line">    <span class="keyword">int</span> point2;</span><br><span class="line">    <span class="keyword">int</span> cost;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Edge</span><span class="params">(<span class="keyword">int</span> point1, <span class="keyword">int</span> point2, <span class="keyword">int</span> cost)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.point1 = point1;</span><br><span class="line">      <span class="keyword">this</span>.point2 = point2;</span><br><span class="line">      <span class="keyword">this</span>.cost = cost;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Time Complexity: <span style="background-color:yellow">O(ElogV)</span></strong></p>
<ul>
<li>V represents the number of vertices, E represents the total number of edges. In our template, <code>E = V · (V - 1)</code>.</li>
<li>We need O(V + E) time to traverse all the vertices of the graph, and we store in the heap all the vertices that are not yet included in our MST.</li>
<li>Pop out vertices from priority queue takes O(logV) time.</li>
<li>Therefore, the overall time complexity is <code>O(V + E) · O(log V) = O(ElogV)</code>.</li>
</ul>
<p><strong>Space Complexity: <span style="background-color:yellow">O(V)</span></strong></p>
<ul>
<li>V represents the number of vertices, Store all edges stating from one point in a priority queue takes O(V) sapce.</li>
</ul>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a><span style="color:red">Reference</span></h3><ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/explore/learn/card/graph/621/algorithms-to-construct-minimum-spanning-tree">https://leetcode.com/explore/learn/card/graph/621/algorithms-to-construct-minimum-spanning-tree</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/02/19/Minimum-Spanning-Tree/" data-id="ckzw6agpg0008qgvb28e0ht90" data-title="Minimum Spanning Tree" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Depth-First-Search" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/02/18/Depth-First-Search/" class="article-date">
  <time class="dt-published" datetime="2022-02-18T08:00:00.000Z" itemprop="datePublished">2022-02-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/02/18/Depth-First-Search/">Depth First Search</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="What-is-Depth-First-Search"><a href="#What-is-Depth-First-Search" class="headerlink" title="What is Depth First Search?"></a><span style="color:red">What is Depth First Search?</span></h3><p>Depth First Search (DFS) is an <span style="background-color:yellow"><strong>algorithm</strong></span> usually used to:</p>
<ul>
<li>Traverse all nodes in a graph, tree or 2D array.</li>
<li>Search if there is a path from the root node to the target node in a graph, tree or 2D array.</li>
<li>Find all paths from the root node to the target node in a graph, tree or 2D array.</li>
</ul>
<hr>
<h3 id="Template-1"><a href="#Template-1" class="headerlink" title="Template 1"></a><span style="color:red">Template 1</span></h3><p><strong>Recursion template of DFS to find if there is a path from curr node to target node.</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// initially visited should contain curr node</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">DFS</span><span class="params">(Node curr, Node target, Set&lt;Node&gt; visited)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (curr == target) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (Node next : curr.neighbors) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!visited.contains(next)) &#123;</span><br><span class="line">      visited.add(next);</span><br><span class="line">      <span class="keyword">if</span> (DFS(next, target, visited)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Key-Attributes"><a href="#Key-Attributes" class="headerlink" title="Key Attributes:"></a>Key Attributes:</h4><ul>
<li>We are using the implicit stack provided by the system, also known as the Call Stack.</li>
<li>If the depth of recursion is too high, you will suffer from stack overflow.</li>
</ul>
<hr>
<h3 id="Template-2"><a href="#Template-2" class="headerlink" title="Template 2"></a><span style="color:red">Template 2</span></h3><p><strong>Template of DFS using an explicit stack to find if there is a path from curr node to target node.</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">DFS</span><span class="params">(Node root, Node target)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root == target) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Deque&lt;Node&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">  Set&lt;Node&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">  stack.push(root);</span><br><span class="line">  visited.add(root);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">    Node curr = stack.pop();</span><br><span class="line">    <span class="keyword">if</span> (curr == target) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Node next : curr.neighbors) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!visited.contains(next)) &#123;</span><br><span class="line">        stack.push(next);</span><br><span class="line">        visited.add(next);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Key-Attributes-1"><a href="#Key-Attributes-1" class="headerlink" title="Key Attributes:"></a>Key Attributes:</h4><ul>
<li>The logic is exactly the same with the recursion solution. But we use while loop and stack to simulate the system call stack during recursion.</li>
</ul>
<h3 id="Time-and-Space-Complexity"><a href="#Time-and-Space-Complexity" class="headerlink" title="Time and Space Complexity"></a><span style="color:red">Time and Space Complexity</span></h3><p><strong>Time Complexity: <span style="background-color:yellow">O(V + E)</span></strong><br>V represents the number of vertices, and E represents the number of edges. We need to check every vertex and traverse through every edge in the graph.</p>
<p><strong>Space Complexity: <span style="background-color:yellow">O(V)</span></strong><br>Either the manually created stack or the recursive call stack can store up to V vertices.</p>
<h3 id="Further-Discussion"><a href="#Further-Discussion" class="headerlink" title="Further Discussion"></a><span style="color:red">Further Discussion</span></h3><p>DFS can be used to find all paths from the source vertex to the target vertex on a directed acyclic graph (DAG)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Given a directed acyclic graph (DAG) of n nodes labeled from 0 to n - 1,</span></span><br><span class="line"><span class="comment">find all possible paths from node 0 to node n - 1 and return them in any order.</span></span><br><span class="line"><span class="comment">graph[i] is a list of all nodes you can visit from node i (i.e., there is a directed edge from node i to node graph[i][j]).</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; allPathsSourceTarget(<span class="keyword">int</span>[][] graph) &#123;</span><br><span class="line">  List&lt;List&lt;Integer&gt;&gt; paths = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  dfs(graph, <span class="number">0</span>, <span class="keyword">new</span> ArrayList&lt;&gt;(), paths);</span><br><span class="line">  <span class="keyword">return</span> paths;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// this is also regarded as backtrack solution</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] graph, <span class="keyword">int</span> node, List&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; paths)</span> </span>&#123;</span><br><span class="line">  path.add(node);</span><br><span class="line">  <span class="keyword">if</span> (node == graph.length - <span class="number">1</span>) &#123;</span><br><span class="line">    paths.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> next : graph[node]) &#123;</span><br><span class="line">    dfs(graph, next, path, paths);</span><br><span class="line">    path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Time Complexity: <span style="background-color:yellow">O(2<sup>V</sup> · V)</span></strong></p>
<ul>
<li>V represents the number of vertices.</li>
<li>For a directed acyclic graph (DAG) with V vertices, there could be at most 2<sup>V - 1</sup> - 1 possible paths to go from the starting vertex to the target vertex. We need O(V) time to build each such path.</li>
<li>Therefore, a loose upper bound on the time complexity would be O(2<sup>V - 1</sup> - 1) · O(V) = O(2<sup>V</sup> · V).</li>
<li>Since we have overlap between the paths, the actual time spent on the traversal will be lower to some extent.</li>
</ul>
<p><strong>Space Complexity: <span style="background-color:yellow">O(2<sup>V</sup> · V)</span></strong></p>
<ul>
<li>The recursion depth can be no more than V, and we need O(V) space to store all the previously visited vertices while recursively traversing deeper with the current path.</li>
<li>since at most we could have 2<sup>V - 1</sup> - 1 possible paths as the results and each path can contain up to V vertices, the space we need to store the results would be O(2<sup>V - 1</sup> - 1) · O(V) = O(2<sup>V</sup> · V).</li>
<li>To sum up, the space complexity of the algorithm is O(V) + O(2<sup>V - 1</sup> - 1) · O(V) = O(2<sup>V</sup> · V).</li>
</ul>
<p><strong>related questions:</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/all-paths-from-source-to-target/">https://leetcode.com/problems/all-paths-from-source-to-target/</a></li>
</ul>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a><span style="color:red">Reference</span></h3><ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/explore/learn/card/queue-stack/232/practical-application-stack/">https://leetcode.com/explore/learn/card/queue-stack/232/practical-application-stack/</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/explore/learn/card/graph/619/depth-first-search-in-graph">https://leetcode.com/explore/learn/card/graph/619/depth-first-search-in-graph</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/02/18/Depth-First-Search/" data-id="ckzw6agpd0002qgvb0mzt2mm6" data-title="Depth First Search" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Breadth-First-Search" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/02/18/Breadth-First-Search/" class="article-date">
  <time class="dt-published" datetime="2022-02-18T08:00:00.000Z" itemprop="datePublished">2022-02-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/02/18/Breadth-First-Search/">Breadth First Search</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="What-is-Breadth-First-Search"><a href="#What-is-Breadth-First-Search" class="headerlink" title="What is Breadth First Search?"></a><span style="color:red">What is Breadth First Search?</span></h3><p>Breadth First Search (BFS) is an <span style="background-color:yellow"><strong>algorithm</strong></span> usually used to：</p>
<ul>
<li>Traverse all nodes level by level in a graph, tree or 2D array.</li>
<li>Find the shortest path from the root node to the target node in a graph, tree or 2D array.</li>
</ul>
<hr>
<h3 id="Template-1"><a href="#Template-1" class="headerlink" title="Template 1"></a><span style="color:red">Template 1</span></h3><p><strong>Most basic and elementary form of BFS to traverse all nodes in a Binary Tree.</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;Node&gt; <span class="title">BFS</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">  List&lt;Node&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">  queue.offer(root);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">    Node curr = queue.poll();</span><br><span class="line">    ans.add(curr);</span><br><span class="line">    <span class="keyword">if</span> (curr.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">      queue.offer(curr.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (curr.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">      queue.offer(curr.right);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Key-Attributes"><a href="#Key-Attributes" class="headerlink" title="Key Attributes:"></a>Key Attributes:</h4><ul>
<li>Since we only want to traverse all nodes in a Binary Tree, we do not need to worry about detecting cycles or care about different levels of the tree, just add left and right children of the current node to the queue if they are not null.</li>
</ul>
<hr>
<h3 id="Template-2"><a href="#Template-2" class="headerlink" title="Template 2"></a><span style="color:red">Template 2</span></h3><p><strong>Find the shortest path from the root node to the target node in a tree or a directed acyclic graph (DAG).</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BFS</span><span class="params">(Node root, Node target)</span> </span>&#123;</span><br><span class="line">  Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">  queue.offer(root);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">int</span> size = queue.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">      Node curr = queue.poll();</span><br><span class="line">      <span class="keyword">if</span> (curr == target) &#123;</span><br><span class="line">        <span class="keyword">return</span> step;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">      Add children nodes of a tree or neighbors in a graph to the queue</span></span><br><span class="line"><span class="comment">      e.g. If we are traversing a Binary Tree,</span></span><br><span class="line"><span class="comment">      we should add curr.left and curr.right to the queue if they are not null</span></span><br><span class="line"><span class="comment">      **/</span></span><br><span class="line">      <span class="keyword">for</span> (Node next : curr.neighbors) &#123;</span><br><span class="line">        queue.offer(next);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    step++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return -1 if there is no path from root to target</span></span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Key-Attributes-1"><a href="#Key-Attributes-1" class="headerlink" title="Key Attributes:"></a>Key Attributes:</h4><ul>
<li>As shown in the code, in each round, we need to keep the current queue size, nodes inside this range are from the current level we are working on.</li>
<li>After each outer while loop, we are one step farther from the root node. The variable step indicates the distance from the root node and the current node we are visiting.</li>
<li>There is a variant of increasing step, instead of updating step at the end of the while loop, we can also increasing step at the beginning of the while loop:</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">  step++;</span><br><span class="line">  <span class="keyword">int</span> size = queue.size();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">    Node curr = queue.poll();</span><br><span class="line">    <span class="keyword">for</span> (Node next : curr.neighbors) &#123;</span><br><span class="line">      <span class="keyword">if</span> (next == target) &#123;</span><br><span class="line">        <span class="keyword">return</span> step;</span><br><span class="line">      &#125;</span><br><span class="line">      queue.offer(next);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>In this way, we can terminate the finding process even earlier, but we need to be carefull about handling the initial root node firstly before we go to the while loop.</p>
<hr>
<h3 id="Template-3"><a href="#Template-3" class="headerlink" title="Template 3"></a><span style="color:red">Template 3</span></h3><p><strong>If we need to make sure that we never visit a node twice or want to avoid getting stuck in an infinite loop in a graph with cycle, we can keep a set to contain all node we have visited.</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BFS</span><span class="params">(Node root, Node target)</span> </span>&#123;</span><br><span class="line">  Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">  Set&lt;Node&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  queue.offer(root);</span><br><span class="line">  visited.add(root);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">int</span> size = queue.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">      Node curr = queue.poll();</span><br><span class="line">      <span class="keyword">if</span> (curr == target) &#123;</span><br><span class="line">        <span class="keyword">return</span> step;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (Node next : curr.neighbors) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited.contains(next)) &#123;</span><br><span class="line">          queue.offer(next);</span><br><span class="line">          visited.add(next);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    step++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Key-Attributes-2"><a href="#Key-Attributes-2" class="headerlink" title="Key Attributes:"></a>Key Attributes:</h4><ul>
<li>Key difference between this template and template 2 is that here we keep a set to contain all visited nodes, before we add a new node to the queue, we need to check if the node is already in the set.</li>
<li>This template is used if you are given a graph that may have cycles or you do not want to visit a node multiple times like traversing in an 2D array.</li>
</ul>
<h3 id="Time-and-Space-Complexity"><a href="#Time-and-Space-Complexity" class="headerlink" title="Time and Space Complexity"></a><span style="color:red">Time and Space Complexity</span></h3><table>
<thead>
<tr>
<th></th>
<th>Binary Tree/ N-ary Tree</th>
<th>Graph</th>
<th>2D Array</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Time Complexity:</strong></td>
<td><span style="background-color:yellow"><strong>O(N)</strong></span></td>
<td><span style="background-color:yellow"><strong>O(V + E)</strong></span></td>
<td><span style="background-color:yellow"><strong>O(M * N)</strong></span></td>
</tr>
</tbody></table>
<ul>
<li>In the Binary Tree or N-ary Tree, N represents the number of nodes, the number of edges will be exactly N - 1, so together the time complexity is O(N).</li>
<li>In the graph, V represents the number of vertices, and E represents the number of edges. We need to check every vertex and traverse through every edge in the graph.</li>
<li>In the 2D array of size M * N, we need to traverse all elements in the matrix, so the time complexity is O(M * N).</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>Binary Tree/ N-ary Tree</th>
<th>Graph</th>
<th>2D Array</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Space Complexity:</strong></td>
<td><span style="background-color:yellow"><strong>O(N)</strong></span></td>
<td><span style="background-color:yellow"><strong>O(V)</strong></span></td>
<td><span style="background-color:yellow"><strong>O(M * N)</strong></span></td>
</tr>
</tbody></table>
<ul>
<li>In the Binary Tree or N-ary Tree, at worst case we need to hold all nodes in the queue.</li>
<li>In the graph, we will check if a vertex has been visited before adding it to the queue, so the queue will use at most O(V) space. Keeping track of which vertices have been visited will also require O(V) space.</li>
<li>In the 2D array, at worst case we need to hold all elements in the queue. Keeping track of which elements have been visited will also require O(M * N) space.</li>
</ul>
<h3 id="Further-Discussion"><a href="#Further-Discussion" class="headerlink" title="Further Discussion"></a><span style="color:red">Further Discussion</span></h3><p>Template 3 is also widely used in searching a 2D Array. The question may define that we can search 4 directions from one point, that is up, down, left and right. In this case, we can predefine a direction array and use it when we want to generate new points.</p>
<p><strong>Find the shortest path from the start point to the target point in a 2D array.</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span>[][] mat, <span class="keyword">int</span>[] start, <span class="keyword">int</span>[] target)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> m = mat.length;</span><br><span class="line">  <span class="keyword">int</span> n = mat[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">  Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">  <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line"></span><br><span class="line">  queue.offer(start);</span><br><span class="line">  visited[start[<span class="number">0</span>]][start[<span class="number">1</span>]] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// define directions vector in clockwise direction: up, right, down, left</span></span><br><span class="line">  <span class="keyword">int</span>[][] DIRS = &#123;&#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">int</span> size = queue.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span>[] curr = queue.poll();</span><br><span class="line">      <span class="keyword">int</span> row = curr[<span class="number">0</span>];</span><br><span class="line">      <span class="keyword">int</span> col = curr[<span class="number">1</span>];</span><br><span class="line">      <span class="keyword">if</span> (row == target[<span class="number">0</span>] &amp;&amp; col == target[<span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> step;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span>[] dir : DIRS) &#123;</span><br><span class="line">        <span class="keyword">int</span> r = row + dir[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> c = col + dir[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (r &lt; <span class="number">0</span> || r &gt;= m || c &lt; <span class="number">0</span> || c &gt;= n || visited[r][c]) &#123;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r, c&#125;);</span><br><span class="line">        visited[r][c] = <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    step++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a><span style="color:red">Reference</span></h3><ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/explore/learn/card/queue-stack/231/practical-application-queue/">https://leetcode.com/explore/learn/card/queue-stack/231/practical-application-queue/</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/explore/learn/card/graph/620/breadth-first-search-in-graph/3883/">https://leetcode.com/explore/learn/card/graph/620/breadth-first-search-in-graph/3883/</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/02/18/Breadth-First-Search/" data-id="ckzw6agpd0003qgvb82nj5f7n" data-title="Breadth First Search" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Disjoint-Set" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/02/18/Disjoint-Set/" class="article-date">
  <time class="dt-published" datetime="2022-02-18T08:00:00.000Z" itemprop="datePublished">2022-02-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/02/18/Disjoint-Set/">Disjoint Set</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="What-is-Disjoint-Set"><a href="#What-is-Disjoint-Set" class="headerlink" title="What is Disjoint Set?"></a><span style="color:red">What is Disjoint Set?</span></h3><ul>
<li>Disjoint Set is a <span style="background-color:yellow"><strong>data structure</strong></span> usually applied in a graph, also known as Union Find data structure.</li>
<li>The primary use of Disjoint Set is to address the connectivity between the components of a network. The “network” here can be a computer network or a social network. For instance, we can use a Disjoint Set to determine if two people share a common ancestor.</li>
<li>The main idea of Disjoint Set is to have all connected vertices have the same root node, whether directly or indirectly connected. In this way if we want to check two vertices are connected, we only need to check if they have the same root node.</li>
</ul>
<h3 id="Two-essential-functions-of-Disjoint-Set"><a href="#Two-essential-functions-of-Disjoint-Set" class="headerlink" title="Two essential functions of Disjoint Set"></a><span style="color:red">Two essential functions of Disjoint Set</span></h3><ul>
<li><span style="background-color:yellow"><strong>Find</strong></span> function finds the root node of a given vertex.</li>
<li><span style="background-color:yellow"><strong>Union</strong></span> function connects previously unconnected two vertices by making their root nodes the same.</li>
<li>There is another important function named <strong>connected</strong>, which checks the connectivity of two vertices.</li>
</ul>
<h3 id="Two-basic-ways-to-implement-Disjoint-Set"><a href="#Two-basic-ways-to-implement-Disjoint-Set" class="headerlink" title="Two basic ways to implement Disjoint Set"></a><span style="color:red">Two basic ways to implement Disjoint Set</span></h3><ul>
<li><strong>implementation with <span style="background-color:yellow">Quick Find</span></strong>: The time complexity of the find function will be O(1), the union function will take more time with the time complexity of O(N).</li>
<li><strong>implementation with <span style="background-color:yellow">Quick Union</span></strong>: Compared with the quick find implementation, the find function will take more time in this case wiht the time complexity of O(N), the time complexity of the union function is also O(N), but performs better than the union functon of Quick Find implementation.</li>
</ul>
<h3 id="Two-common-strategies-to-optimize-Disjoint-Set"><a href="#Two-common-strategies-to-optimize-Disjoint-Set" class="headerlink" title="Two common strategies to optimize Disjoint Set"></a><span style="color:red">Two common strategies to optimize Disjoint Set</span></h3><ul>
<li><span style="background-color:yellow"><strong>Path Compression</strong></span>: This optimization is after finding the root node of a given vertex, we update the parent node of all traversed vertices to their root node. When we search for the root node of the same vertex again, we only need to traverse two vertices to find its root node, which is highly efficient. The time complexity of find function is reduced from O(n) to O(logn).</li>
<li><span style="background-color:yellow"><strong>Union by Rank</strong></span>: For the union function, instead of always picking the root of the first vertex as the new root node, we choose the root node of the vertex with a larger “rank”. We will merge the shorter tree under the taller tree and assign the root node of the taller tree as the root node for both vertices. In this way, we effectively avoid the possibility of connecting all vertices into a straight line. The time complexity of union function is reduced from O(n) to O(logn).</li>
</ul>
<h3 id="Optimized-Disjoint-Set-with-path-compression-and-union-by-rank"><a href="#Optimized-Disjoint-Set-with-path-compression-and-union-by-rank" class="headerlink" title="Optimized Disjoint Set with path compression and union by rank"></a><span style="color:red">Optimized Disjoint Set with path compression and union by rank</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span>[] root;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span>[] rank;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    root = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">    rank = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">      root[i] = i;</span><br><span class="line">      rank[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == root[x]) &#123;</span><br><span class="line">      <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root[x] = find(root[x]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rootX = find(x);</span><br><span class="line">    <span class="keyword">int</span> rootY = find(y);</span><br><span class="line">    <span class="keyword">if</span> (rootX == rootY) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rank[rootX] &gt; rank[rootY]) &#123;</span><br><span class="line">      root[rootY] = rootX;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rank[rootX] &lt; rank[rootY]) &#123;</span><br><span class="line">      root[rootX] = rootY;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      root[rootY] = rootX;</span><br><span class="line">      rank[rootX]++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> find(x) == find(y);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Time-and-Space-Complexity"><a href="#Time-and-Space-Complexity" class="headerlink" title="Time and Space Complexity"></a><span style="color:red">Time and Space Complexity</span></h3><table>
<thead>
<tr>
<th></th>
<th>Union-find Constructor</th>
<th>Find</th>
<th>Union</th>
<th>Connected</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Time Complexity:</strong></td>
<td><span style="background-color:yellow"><strong>O(N)</strong></span></td>
<td><span style="background-color:yellow"><strong>O(α(N))</strong></span></td>
<td><span style="background-color:yellow"><strong>O(α(N))</strong></span></td>
<td><span style="background-color:yellow"><strong>O(α(N))</strong></span></td>
</tr>
</tbody></table>
<p>N is the number of vertices in the graph. α refers to the Inverse Ackermann function. In practice, we assume it is a constant. In other words, O(α(N)) is regarded as O(1) on average.</p>
<p><strong>Space Complexity: <span style="background-color:yellow">O(N)</span></strong><br>We need two arrays of size N to record root nodes and rank of root nodes.</p>
<h3 id="Further-Discussion"><a href="#Further-Discussion" class="headerlink" title="Further Discussion"></a><span style="color:red">Further Discussion</span></h3><p>In some problems, we are required to return the number of different groups or some extra information like the size of the maximum group. To get these information, we can keep some variables and update them while union two vertices.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span>[] root;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span>[] rank;</span><br><span class="line">  <span class="comment">// returns the number of different groups</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span> groups;</span><br><span class="line">  <span class="comment">// returns the size of the largest group</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span> maxGroupSize;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    root = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">    rank = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">      root[i] = i;</span><br><span class="line">      <span class="comment">// here rank array keeps the size of each group</span></span><br><span class="line">      rank[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// initially all vertices are independent groups of size 1</span></span><br><span class="line">    groups = size;</span><br><span class="line">    <span class="comment">// initially all groups have one element</span></span><br><span class="line">    maxGroupSize = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == root[x]) &#123;</span><br><span class="line">      <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root[x] = find(root[x]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rootX = find(x);</span><br><span class="line">    <span class="keyword">int</span> rootY = find(y);</span><br><span class="line">    <span class="keyword">if</span> (rootX == rootY) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rank[rootX] &gt;= rank[rootY]) &#123;</span><br><span class="line">      root[rootY] = rootX;</span><br><span class="line">      rank[rootX] += rank[rootY];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      root[rootX] = rootY;</span><br><span class="line">      rank[rootY] += rank[rootX];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// each valid union operation will reduce the number of groups by one</span></span><br><span class="line">    groups--;</span><br><span class="line">    <span class="comment">// update maxGroupSize in each valid union</span></span><br><span class="line">    maxGroupSize = Math.max(maxGroupSize, Math.max(rank[rootX], rank[rootY]));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> find(x) == find(y);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>related questions:</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/groups-of-strings/">https://leetcode.com/problems/groups-of-strings/</a></li>
</ul>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a><span style="color:red">Reference</span></h3><ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/explore/learn/card/graph/618/disjoint-set">https://leetcode.com/explore/learn/card/graph/618/disjoint-set</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/02/18/Disjoint-Set/" data-id="ckzw6agpf0006qgvb0lt015b5" data-title="Disjoint Set" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Trie" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/02/18/Trie/" class="article-date">
  <time class="dt-published" datetime="2022-02-18T08:00:00.000Z" itemprop="datePublished">2022-02-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/02/18/Trie/">Trie</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="What-is-Trie"><a href="#What-is-Trie" class="headerlink" title="What is Trie?"></a><span style="color:red">What is Trie?</span></h3><ul>
<li>A Trie is a special form of a Nary tree.</li>
<li>Typically, Trie is a <span style="background-color:yellow"><strong>data structure</strong></span> to be used to store and search strings. Each Trie node represents a string (a prefix).</li>
<li>The root node is associated with the empty string.</li>
<li>All the descendants of a node have a common prefix of the string associated with that node. That’s why Trie is also called prefix tree.</li>
<li>Trie is widely used in various applications, such as autocomplete, spell checker, etc.</li>
</ul>
<h3 id="Two-representations-of-a-Trie-node"><a href="#Two-representations-of-a-Trie-node" class="headerlink" title="Two representations of a Trie node"></a><span style="color:red">Two representations of a Trie node</span></h3><ul>
<li>The first solution is to use an <strong>array</strong> to store children nodes.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">  <span class="comment">// change this value to adapt to different cases</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> N = <span class="number">26</span>;</span><br><span class="line">  <span class="keyword">public</span> TrieNode[] children = <span class="keyword">new</span> TrieNode[N];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// you might need some extra values according to different cases</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>It is really fast to visit a child node. If we are pursing fast time performence, we can use array to store TrieNode. It is comparatively easy to visit a specific child since we can easily transfer a character to an index in most cases. But not all children nodes are needed. So there might be some waste of space.</p>
<ul>
<li>The second solution is to use a <strong>hashmap</strong> to store children nodes.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> Map&lt;Character, TrieNode&gt; children = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// you might need some extra values according to different cases</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>It is even easier to visit a specific child directly by the corresponding character. But it might be a little slower than using an array. However, it saves some space since we only store the children nodes we need. It is also more flexible because we are not limited by a fixed length and fixed range.</p>
<h3 id="Implement-Trie"><a href="#Implement-Trie" class="headerlink" title="Implement Trie"></a><span style="color:red">Implement Trie</span></h3><p>Implement a trie with <strong>insert</strong>, <strong>search</strong>, and <strong>startsWith</strong> methods.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Map&lt;Character, TrieNode&gt; children = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> isWord;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> TrieNode root;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Insert a word into the Trie</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">    TrieNode curr = root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : word.toCharArray()) &#123;</span><br><span class="line">      curr.children.putIfAbsent(c, <span class="keyword">new</span> TrieNode());</span><br><span class="line">      curr = curr.children.get(c);</span><br><span class="line">    &#125;</span><br><span class="line">    curr.isWord = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return true if the word is in the Trie</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">    TrieNode curr = root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : word.toCharArray()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (curr.children.get(c) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      curr = curr.children.get(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curr.isWord;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return true if there is any word in the Trie that starts with the given prefix</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">    TrieNode curr = root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : prefix.toCharArray()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (curr.children.get(c) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      curr = curr.children.get(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Time-and-Space-Complexity"><a href="#Time-and-Space-Complexity" class="headerlink" title="Time and Space Complexity"></a><span style="color:red">Time and Space Complexity</span></h3><table>
<thead>
<tr>
<th></th>
<th>Trie Constructor</th>
<th>insert</th>
<th>search</th>
<th>startsWith</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Time Complexity:</strong></td>
<td><span style="background-color:yellow"><strong>O(1)</strong></span></td>
<td><span style="background-color:yellow"><strong>O(N)</strong></span></td>
<td><span style="background-color:yellow"><strong>O(N)</strong></span></td>
<td><span style="background-color:yellow"><strong>O(N)</strong></span></td>
</tr>
</tbody></table>
<p>If the longest length of the word is N, the height of the Trie will be N + 1. Therefore, the time complexity of all insert, search and startsWith methods will be O(N).</p>
<p><strong>Space Complexity: <span style="background-color:yellow"> O(M * N * K)</span></strong><br>If we have M words to insert in total and the length of words is at most N, there will be at most M * N nodes in the worst case (any two words don’t have a common prefix).</p>
<p>Let’s assume that there are maximum K different characters (K is equal to 26 in the case of strings only containing lowercase english characters, but might differs in different cases.) So each node will maintain a map or array whose size is at most K.</p>
<p>Therefore, the sapce complexity will be O(M * N * K).</p>
<p>In real cases, the space complexity should be much smaller than our estimation, especially when the distribution of words is dense.</p>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a><span style="color:red">Reference</span></h3><ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/explore/learn/card/trie/">https://leetcode.com/explore/learn/card/trie/</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/02/18/Trie/" data-id="ckzw6agph000aqgvb52b42kwc" data-title="Trie" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/02/20/Heap/">Heap</a>
          </li>
        
          <li>
            <a href="/2022/02/20/Monotonic-Stack/">Monotonic Stack</a>
          </li>
        
          <li>
            <a href="/2022/02/20/Topological-Sorting/">Topological Sorting</a>
          </li>
        
          <li>
            <a href="/2022/02/19/Bellman-Ford-Algorithm/">Bellman Ford Algorithm</a>
          </li>
        
          <li>
            <a href="/2022/02/19/Dijkstra's-Algorithm/">Dijkstra&#39;s Algorithm</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 Yang Xiao<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>