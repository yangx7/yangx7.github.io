<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Minimum Spanning Tree | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="What is Minimum Spanning Tree?A Spanning Tree is a connected subgraph in an undirected graph where all vertices are connected with the minimum number of edges.In the below figure, all pink edges [(A,">
<meta property="og:type" content="article">
<meta property="og:title" content="Minimum Spanning Tree">
<meta property="og:url" content="http://example.com/2022/02/19/Minimum-Spanning-Tree/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="What is Minimum Spanning Tree?A Spanning Tree is a connected subgraph in an undirected graph where all vertices are connected with the minimum number of edges.In the below figure, all pink edges [(A,">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://s2.loli.net/2022/02/19/J7AEUHv8MX5qZlL.png">
<meta property="og:image" content="https://s2.loli.net/2022/02/19/Sbumhe7NR9EBnw4.png">
<meta property="og:image" content="https://s2.loli.net/2022/02/19/IZTp5qkSXb746Mz.png">
<meta property="article:published_time" content="2022-02-19T08:00:00.000Z">
<meta property="article:modified_time" content="2022-02-21T04:30:52.147Z">
<meta property="article:author" content="Yang Xiao">
<meta property="article:tag" content="algorithm">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2022/02/19/J7AEUHv8MX5qZlL.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-Minimum-Spanning-Tree" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/02/19/Minimum-Spanning-Tree/" class="article-date">
  <time class="dt-published" datetime="2022-02-19T08:00:00.000Z" itemprop="datePublished">2022-02-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      Minimum Spanning Tree
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="What-is-Minimum-Spanning-Tree"><a href="#What-is-Minimum-Spanning-Tree" class="headerlink" title="What is Minimum Spanning Tree?"></a><span style="color:red">What is Minimum Spanning Tree?</span></h3><p>A <strong>Spanning Tree</strong> is a connected subgraph in an undirected graph where all vertices are connected with the minimum number of edges.<br>In the below figure, all pink edges <span style="background-color:yellow">[(A, B), (A, C), (A, D), (A, E)]</span> form a tree, which is a spanning tree of this undirected graph. Note that <span style="background-color:yellow">[(A, E), (A, B), (B, C), (C, D)]</span> is also a spanning tree of the undirected graph. <strong>Thus, an undirected graph can have multiple spanning trees</strong>.<br><img src="https://s2.loli.net/2022/02/19/J7AEUHv8MX5qZlL.png" width="60%"></p>
<p>A <strong>Minimum Spanning Tree (MST)</strong> is a spanning tree with the minimum possible total edge weight in a weighted undirected graph.<br>In the below figure, a spanning tree formed by green edges <span style="background-color:yellow">[(A, E), (A, B), (B, C), (C, D)]</span> is one of the minimum spanning trees in this weighted undirected graph. Actually, <span style="background-color:yellow">[(A, E), (E, D), (A, B), (B, C)]</span> forms another minimum spanning tree of the weighted undirected graph. <strong>Thus, a weighted undirected graph can have multiple minimum spanning trees</strong>.<br><img src="https://s2.loli.net/2022/02/19/Sbumhe7NR9EBnw4.png" width="60%"></p>
<h3 id="Cut-Property"><a href="#Cut-Property" class="headerlink" title="Cut Property"></a><span style="color:red">Cut Property</span></h3><ul>
<li>In Graph theory, a “cut” is a partition of vertices in a graph into two disjoint subsets. Below figure illustrates a “cut”, where (B, A, E) forms one subset, and (C, D) forms the other subset.</li>
<li>A crossing edge is an edge that connects a vertex in one set with a vertex in the other set. In the below figure, (B, C), (A, C), (A, D), (E, D) are all “crossing edges”.<img src="https://s2.loli.net/2022/02/19/IZTp5qkSXb746Mz.png" width="60%"></li>
</ul>
<p><span style="background-color:yellow"><strong>For any cut C of the graph, if the weight of an edge E in the cut-set of C is strictly smaller than the weights of all other edges of the cut-set of C, then this edge belongs to all MSTs of the graph.</strong></span></p>
<p>So in the above figure, (B, C) belongs to all MSTs of the graph. The cut property provides theoretical support for the two algorithms for constructing a minimum spanning tree: Kruskal’s algorithm and Prim’s algorithm.</p>
<h3 id="Kruskal’s-Algorithm"><a href="#Kruskal’s-Algorithm" class="headerlink" title="Kruskal’s Algorithm"></a><span style="color:red">Kruskal’s Algorithm</span></h3><p>Kruskal’s algorithm is an <span style="background-color:yellow"><strong>algorithm</strong></span> to construct a MST of a weighted undirected graph.</p>
<p><strong>Algorithm</strong>:</p>
<ol>
<li> Ascending sort all edges by their weight. In practice, we can use min heap to get the edge wih the smallest weight.</li>
<li> Add edges in ascending order into the MST. Skip the edges that would produce cycles in the MST.</li>
<li> Repeat step 2 until <code>N - 1</code> edges are added.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  Given an array points representing integer coordinates of some points on a 2D-plane,</span></span><br><span class="line"><span class="comment">  where points[i] = [xi, yi].</span></span><br><span class="line"><span class="comment">  The cost of connecting two points [xi, yi] and [xj, yj] is the manhattan distance between them:</span></span><br><span class="line"><span class="comment">  |xi - xj| + |yi - yj|, where |val| denotes the absolute value of val.</span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Kruskal</span><span class="params">(<span class="keyword">int</span>[][] points)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (points == <span class="keyword">null</span> || points.length == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> size = points.length;</span><br><span class="line">    UnionFind uf = <span class="keyword">new</span> UnionFind(size);</span><br><span class="line">    PriorityQueue&lt;Edge&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((p1, p2) -&gt; p1.cost - p2.cost);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span>[] p1 = points[i];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; size; j++) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] p2 = points[j];</span><br><span class="line">        <span class="keyword">int</span> cost = Math.abs(p1[<span class="number">0</span>] - p2[<span class="number">0</span>]) + Math.abs(p1[<span class="number">1</span>] - p2[<span class="number">1</span>]);</span><br><span class="line">        Edge edge = <span class="keyword">new</span> Edge(i, j, cost);</span><br><span class="line">        pq.add(edge);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// to construct MST, we need (size - 1) edges</span></span><br><span class="line">    <span class="keyword">int</span> count = size - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!pq.isEmpty() &amp;&amp; count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      Edge edge = pq.poll();</span><br><span class="line">      <span class="keyword">if</span> (!uf.connected(edge.point1, edge.point2)) &#123;</span><br><span class="line">        uf.union(edge.point1, edge.point2);</span><br><span class="line">        ans += edge.cost;</span><br><span class="line">        count--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Edge</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> point1;</span><br><span class="line">    <span class="keyword">int</span> point2;</span><br><span class="line">    <span class="keyword">int</span> cost;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Edge</span><span class="params">(<span class="keyword">int</span> point1, <span class="keyword">int</span> point2, <span class="keyword">int</span> cost)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.point1 = point1;</span><br><span class="line">      <span class="keyword">this</span>.point2 = point2;</span><br><span class="line">      <span class="keyword">this</span>.cost = cost;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] root;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] rank;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">      root = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">      rank = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        root[i] = i;</span><br><span class="line">        rank[i] = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (x == root[x]) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> root[x] = find(root[x]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> rootX = find(x);</span><br><span class="line">      <span class="keyword">int</span> rootY = find(y);</span><br><span class="line">      <span class="keyword">if</span> (rootX == rootY) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (rank[rootX] &gt; rank[rootY]) &#123;</span><br><span class="line">        root[rootY] = rootX;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rank[rootX] &lt; rank[rootY]) &#123;</span><br><span class="line">        root[rootX] = rootY;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        root[rootY] = rootX;</span><br><span class="line">        rank[rootX]++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> find(x) == find(y);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Time Complexity: <span style="background-color:yellow">O(ElogE)</span></strong></p>
<ul>
<li>V represents the number of vertices, E represents the total number of edges. In our template, <code>E = V · (V - 1)</code>.</li>
<li>Building a priority queue takes O(ElogE) time.</li>
<li>To construct MST using Kruskal’s algorithm, We pop out each edge from the priority queue, and for each edge, we will look at whether both of the vertices of the edge belong to the same connected component and connect them if they do not belong to the same connected component. We only need <code>V - 1</code> edges to build MST, but in the worst case, the tree will not be complete until we reach the very last edge whose weight is the largest, it takes O(E) iterations. So it totally takes O(ElogE) time to pop out all edges from priority queue, to check connectivity and union vertices in the Union Find data structure totally takes O(Eα(V)) time, we can regard it as O(E) time.</li>
<li>Therefore, in total, the time complexity is <code>O(ElogE) + O(ElogE) + O(E) = O(ElogE)</code> time.</li>
</ul>
<p><strong>Space Complexity: <span style="background-color:yellow">O(V + E)</span></strong></p>
<ul>
<li>E represents the number of edges. Store all edges in a priority queue takes O(E) sapce.</li>
<li>V represents the number of vertices, Using the Union Find data structure requires O(V) space.</li>
<li>Therefore, in total, the space complexity is <code>O(V) + O(E) = O(V + E)</code> time.</li>
</ul>
<h3 id="Prim’s-Algorithm"><a href="#Prim’s-Algorithm" class="headerlink" title="Prim’s Algorithm"></a><span style="color:red">Prim’s Algorithm</span></h3><p>Prim’s algorithm is an <span style="background-color:yellow"><strong>algorithm</strong></span> to construct a MST of a weighted undirected graph.</p>
<p><strong>Algorithm</strong>:</p>
<ol>
<li> Keep two sets to store vertices: non-visited and visited. Initially, all vertices are in the non-visited set.</li>
<li> Randomly pick one vertex from non-visited set, put it in the visited set.</li>
<li> Among all edges between visited and non-visited vertices, find the edge with the smallest weight.</li>
<li> Move the new non-visited vertex belonging to the edge we found at step 3 to the visited set.</li>
<li> Repeat step 2 and 3 until all vertices are added to the visited set.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  Given an array points representing integer coordinates of some points on a 2D-plane,</span></span><br><span class="line"><span class="comment">  where points[i] = [xi, yi].</span></span><br><span class="line"><span class="comment">  The cost of connecting two points [xi, yi] and [xj, yj] is the manhattan distance between them:</span></span><br><span class="line"><span class="comment">  |xi - xj| + |yi - yj|, where |val| denotes the absolute value of val.</span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Prim</span><span class="params">(<span class="keyword">int</span>[][] points)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (points == <span class="keyword">null</span> || points.length == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> size = points.length;</span><br><span class="line">    <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[size];</span><br><span class="line">    PriorityQueue&lt;Edge&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((p1, p2) -&gt; p1.cost - p2.cost);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// select the first point to be added to the visited set</span></span><br><span class="line">    <span class="keyword">int</span>[] p1 = points[<span class="number">0</span>];</span><br><span class="line">    visited[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span>[] p2 = points[i];</span><br><span class="line">      <span class="keyword">int</span> cost = Math.abs(p1[<span class="number">0</span>] - p2[<span class="number">0</span>]) + Math.abs(p1[<span class="number">1</span>] - p2[<span class="number">1</span>]);</span><br><span class="line">      Edge edge = <span class="keyword">new</span> Edge(<span class="number">0</span>, i, cost);</span><br><span class="line">      pq.add(edge);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// we need to add remaining (size - 1) vertices to the visited set</span></span><br><span class="line">    <span class="keyword">int</span> count = size - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!pq.isEmpty() &amp;&amp; count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      Edge edge = pq.poll();</span><br><span class="line">      <span class="keyword">int</span> p2 = edge.point2;</span><br><span class="line">      <span class="keyword">if</span> (!visited[p2]) &#123;</span><br><span class="line">        visited[p2] = <span class="keyword">true</span>;</span><br><span class="line">        ans += edge.cost;</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> cost = Math.abs(points[p2][<span class="number">0</span>] - points[i][<span class="number">0</span>]) + Math.abs(points[p2][<span class="number">1</span>] - points[i][<span class="number">0</span>]);</span><br><span class="line">            pq.add(<span class="keyword">new</span> Edge(p2, i, cost));</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Edge</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> point1;</span><br><span class="line">    <span class="keyword">int</span> point2;</span><br><span class="line">    <span class="keyword">int</span> cost;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Edge</span><span class="params">(<span class="keyword">int</span> point1, <span class="keyword">int</span> point2, <span class="keyword">int</span> cost)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.point1 = point1;</span><br><span class="line">      <span class="keyword">this</span>.point2 = point2;</span><br><span class="line">      <span class="keyword">this</span>.cost = cost;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Time Complexity: <span style="background-color:yellow">O(ElogV)</span></strong></p>
<ul>
<li>V represents the number of vertices, E represents the total number of edges. In our template, <code>E = V · (V - 1)</code>.</li>
<li>We need O(V + E) time to traverse all the vertices of the graph, and we store in the heap all the vertices that are not yet included in our MST.</li>
<li>Pop out vertices from priority queue takes O(logV) time.</li>
<li>Therefore, the overall time complexity is <code>O(V + E) · O(log V) = O(ElogV)</code>.</li>
</ul>
<p><strong>Space Complexity: <span style="background-color:yellow">O(V)</span></strong></p>
<ul>
<li>V represents the number of vertices, Store all edges stating from one point in a priority queue takes O(V) sapce.</li>
</ul>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a><span style="color:red">Reference</span></h3><ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/explore/learn/card/graph/621/algorithms-to-construct-minimum-spanning-tree">https://leetcode.com/explore/learn/card/graph/621/algorithms-to-construct-minimum-spanning-tree</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/02/19/Minimum-Spanning-Tree/" data-id="cl0wb5god000hysvbhkcehuya" data-title="Minimum Spanning Tree" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/algorithm/" rel="tag">algorithm</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2022/02/19/Dijkstra's-Algorithm/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Dijkstra&#39;s Algorithm
        
      </div>
    </a>
  
  
    <a href="/2022/02/18/Breadth-First-Search/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Breadth First Search</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/algorithm/" rel="tag">algorithm</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/algorithm/" style="font-size: 10px;">algorithm</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/03/16/Bitmasking/">Bitmasking</a>
          </li>
        
          <li>
            <a href="/2022/02/20/Heap/">Heap</a>
          </li>
        
          <li>
            <a href="/2022/02/20/Monotonic-Stack/">Monotonic Stack</a>
          </li>
        
          <li>
            <a href="/2022/02/20/Topological-Sorting/">Topological Sorting</a>
          </li>
        
          <li>
            <a href="/2022/02/19/Bellman-Ford-Algorithm/">Bellman Ford Algorithm</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 Yang Xiao<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>